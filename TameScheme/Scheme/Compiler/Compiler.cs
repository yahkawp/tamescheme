// +----------------------------------------------------------------------------+
// |                               = TAMESCHEME =                               |
// | .NET IL compiler for TameScheme                                Compiler.cs |
// +----------------------------------------------------------------------------+
// | Copyright (c) 2005 Andrew Hunter                                           |
// |                                                                            |
// | Permission is hereby granted, free of charge, to any person obtaining a    |
// | copy of this software and associated documentation files (the "Software"), |
// | to deal in the Software without restriction, including without limitation  |
// | the rights to use, copy, modify, merge, publish, distribute, sublicense,   |
// | and/or sell copies of the Software, and to permit persons to whom the      |
// | Software is furnished to do so, subject to the following conditions:       |
// |                                                                            |
// | The above copyright notice and this permission notice shall be included in |
// | all copies or substantial portions of the Software.                        |
// |                                                                            |
// | THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR |
// | IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   |
// | FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    |
// | THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER |
// | LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    |
// | FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        |
// | DEALINGS IN THE SOFTWARE.                                                  |
// +----------------------------------------------------------------------------+

using System;
using System.Reflection;
using System.Reflection.Emit;

using Tame.Scheme.Runtime;

namespace Tame.Scheme.Compiler
{
    /// <summary>
    /// The compiler class is the base for the TameScheme .NET IL compiler.
    /// </summary>
    public class Compiler
    {
        #region Constructors

        public Compiler()
        {
            // Construct a default assembly and module builder
            lock (typeof(Compiler))
            {
                if (defaultAssembly == null)
                {
                    AppDomain theDomain = System.Threading.Thread.GetDomain();
                    AssemblyName assemblyName = new AssemblyName("CompiledScheme");
                    defaultAssembly = theDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
                    defaultModule = defaultAssembly.DefineDynamicModule("Functions");
                }
            }

            module = defaultModule;
        }

        #endregion

        #region The builders

        // The assembly/module that we use by default for putting code into
        private static AssemblyBuilder defaultAssembly = null;
        private static ModuleBuilder defaultModule = null;

        // The number of the function (when generating names for otherwise unnamed functions)
        private static int functionNumber = 0;

        // The module that this particular compiler is targetting
        private ModuleBuilder module;

        #endregion

        #region Compiler settings

        // Variables and functions that affect the behaviour of the code generated by this compiler

        /// <summary>
        /// Set to true to instruct the compiler to generate code that supports scheme continuations.
        /// </summary>
        private bool allowContinuations = false;

        /// <summary>
        /// Set this flag to true to instruct the compiler to generate 'continuable' code when compiling functions.
        /// </summary>
        /// <remarks>
        /// Continuations are supported in .NET by emulating the scheme stack behaviour. This is somewhat fragile (it is broken when
        /// calling a function that doesn't support the feature, for example), and it also imposes a performance penalty. 
        /// </remarks>
        public bool AllowContinuations
        {
            get
            {
                return allowContinuations;
            }
            set
            {
                allowContinuations = value;
            }
        }

        #endregion

        #region Analysis

        // Functions that help with analysing the code that we're compiling

        #endregion

        #region Emitting code

        /// <summary>
        /// Takes the given scheme and top-level environment and compiles it into an object implementing the
        /// IProcedure inteface. (This compiles a procedure with no arguments)
        /// </summary>
        /// <param name="scheme">The scheme to compile</param>
        /// <param name="topLevel">The top-level environment to compile in</param>
        /// <returns>A new IProcedure object</returns>
        public Type Compile(object scheme, Data.Environment topLevel)
        {
            // Build a BExpression from the supplied scheme
            BExpression expr = BExpression.BuildExpression(scheme, topLevel);
            return Compile(expr, null);
        }

        /// <summary>
        /// Takes a BExpression and compiles an IProcedure object.
        /// </summary>
        /// <param name="expr">The BExpression to compile</param>
        /// <param name="state">The CompileState that the BExpression was compiled under</param>
        /// <returns>A new IProcedure object that executes the given scheme.</returns>
        public Type Compile(BExpression expr, string typeName)
        {
            // Construct a TypeBuilder to compile the type into
            TypeBuilder builder = TypeBuilderForFunction(typeName, null);
            CompileCall(builder, expr);

            // Build the type
            return builder.CreateType();
        }

        /// <summary>
        /// Creates a type builder for a scheme lambda expression.
        /// </summary>
        /// <param name="typeName">The name to give this type (or null if this type should have no name)</param>
        /// <param name="parent">The parent type to nest this type in (or null to define it as part of the module this compiler is handling)</param>
        /// <returns>A new TypeBuilder designed to contain the scheme lambda expression.</returns>
        protected TypeBuilder TypeBuilderForFunction(string typeName, TypeBuilder parent)
        {
            if (typeName == null)
            {
                // Make up a new type name
                lock (typeof(Compiler))
                {
                    typeName = "__SchemeFunction__" + (functionNumber++).ToString();
                }
            }

            lock (module)
            {
                // Create an IProcedure TypeBuilder with this name (public if there's no parent type, private otherwise)
                TypeBuilder procedureType;

                if (parent == null)
                {
                    procedureType = module.DefineType(typeName, TypeAttributes.Class | TypeAttributes.Public | TypeAttributes.Sealed, typeof(Object));
                }
                else
                {
                    procedureType = parent.DefineNestedType(typeName, TypeAttributes.Class | TypeAttributes.NestedPrivate | TypeAttributes.Sealed);
                }

                procedureType.AddInterfaceImplementation(typeof(Procedure.IProcedure));

                return procedureType;
            }
        }

        /// <summary>
        /// Defines a new method builder that implements the IProcedure 'Call' function
        /// </summary>
        /// <param name="typeBuilder">The TypeBuilder to define this Call as a part of</param>
        /// <param name="functionName">The function name to construct</param>
        /// <returns>A new MethodBuilder object that </returns>
        protected MethodBuilder DefineCall(TypeBuilder typeBuilder, string functionName)
        {
            if (functionName == null) functionName = "Call";

            // Define the 'Call' function in the specified type builder and return a suitable method builder
            MethodBuilder call;

            call = typeBuilder.DefineMethod(functionName, MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Final, 
                typeof(object), new Type[] { typeof(Data.Environment), typeof(object[]).MakeByRefType() });

            if (functionName.Equals("Call")) 
            {
                typeBuilder.DefineMethodOverride(call, typeof(Procedure.IProcedure).GetMethod("Call"));
            }

            return call;
        }

        protected void CompileCall(TypeBuilder type, BExpression expr)
        {
            // Create the MethodBuilder that will define this function
            MethodBuilder call = DefineCall(type, null);

            // Create the IL code generator
            ILGenerator il = call.GetILGenerator(8192);

            il.Emit(OpCodes.Ret);

            // Stage 1: analyse the symbol/environment usage

            // Stage 2: create the type and begin compiling the main method

            // Stage 3: compile the bulk of the BExpression
        }

        /// <summary>
        /// Compiles the specified scheme object into a new .NET method. The signature of the method will match 
        /// the IProcedure Call method.
        /// 
        /// I'm defuncting this; too much weight in one function.
        /// </summary>
        /// <param name="scheme">The scheme expression to compile into an IL method.</param>
        /// <param name="argSymbols">The symbols that represents the arguments passed into this method.</param>
        /// <param name="attributes">The attributes to attach to the function that we're going to generate.</param>
        /// <param name="dot">If true, the arguments were created as an improper list: the last argument is turned into a list.</param>
        /// <param name="state">The compiler state for this function (used, for example, to specify what to expect as the Environment parameter)</param>
        /// <param name="methodName">The name for the method that will be created in the typeBuilder.</param>
        /// <param name="typeBuilder">The typeBuilder object to use to add the method to.</param>
        /// <returns>A new MethodBuilder object with the specified scheme compiled into it.</returns>
        public MethodBuilder CompileScheme(object scheme, Data.Symbol[] argSymbols, bool dot, CompileState state, ref TypeBuilder typeBuilder, string methodName, MethodAttributes attributes)
        {
            // Construct the method builder object (TODO: objects are passed in as 'refs': how do we declare this?)
            MethodBuilder schemeBuilder = typeBuilder.DefineMethod(methodName, attributes, typeof(object), new Type[] { typeof(Data.Environment), typeof(object[]) });

            // We don't want to initialise the locals (we do this ourselves)
            schemeBuilder.InitLocals = false;

            // The compile state for this function
            CompileState compileState = new CompileState(state, false);

            // The initial local environment depends on the symbols that are passed as arguments
            compileState.Local = new Data.Environment(compileState.Local);

            foreach (Data.Symbol symbol in argSymbols)
            {
                compileState.Local[symbol] = Data.Unspecified.Value;
            }

            // Compile the scheme into a BExpression
            BExpression expr = BExpression.BuildExpression(scheme, compileState);

            // = Compile the BExpression into IL =

            ILGenerator il = schemeBuilder.GetILGenerator(8192);

            // Construct the environment this function will run in
            LocalBuilder localEnv = il.DeclareLocal(typeof(Data.Environment));

            il.Emit(OpCodes.Ldnull);                // TODO: do something about reconstructing the HybridDictionary for this object
            il.Emit(OpCodes.Ldind_I, compileState.Local.Size);
            il.Emit(OpCodes.Ldarg_0);
            il.Emit(OpCodes.Newobj, typeof(Data.Environment).GetConstructor(new Type[] { typeof(System.Collections.Specialized.HybridDictionary), typeof(int), typeof(Data.Environment) }));

            // Set it as the local environment
            il.Emit(OpCodes.Stloc, localEnv.LocalIndex);

            // Load the arguments from the object list

            // Actually compile the BExpression opcodes

            // Done, return the result
            return schemeBuilder;
        }

        #endregion
    }
}
